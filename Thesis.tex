\documentclass[10pt,a4paper,draft]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{todonotes}
\begin{document}
\begin{flushleft}
\section{Syntax}


\newcommand{\longspace}{\;\;\;\;\;\;}
\newcommand{\inlinecode}{\texttt}
We first introduce the syntax of a MiniML program. A program can consist of a set of modules, consisting of an interface and module body and uniquely identified with a module \textit{name}. The interface and body are represented as a set of declarations $\Delta$ and of definitions $d$ respectively.
The program is concluded by a single naked expression, functioning as the main entry point of the program.
\begin{align*}
\text{Program} ::= \; & \overline{\mathit{Mod}};\;e\\
\text{Module } \mathit{Mod} ::= \; &\lbrace \Delta, \overline{\mathit{d}}\rbrace^{name}\\ 
\\
\text{Declaration } \Delta \; ::=\; &\emptyset \\
&|\; (\mathit{id}:\tau), \Delta \\ 
\\
\text{Definition } d \; ::= \; & \emptyset\\
&| (\mathit{id}=e:\tau), \mathit{d}\\
\\
\text{Expression }e \; ::= \; &\mathit{num \; n \;} | \; \mathit{false} \; | \; \mathit{true} \\
&|\;\mathit{id}  \\
&|\;\mathit{name.id} \\
&|\;\mathit{this.id} \\
&|\;e_{1}e_{2} \\
&|\;(e_{1},e_{2}) \\
&|\;\lambda(p:\tau)\;.\;e \\
&|\;\mathit{let }\; p \; = \; e_{1} \; in \; e_{2} \\
&|\;\mathit{letrec} \; p \; = \; e_{1} \; in \; e_{2} \\
&|\; \mathit{if(e_{1}) \; then \; e_{2} \; else \; e_{3}}\\
&|\;\mathit{p.left}\; | \; \mathit{p.right} \\
&|\;\mathit{fix\;e}\\
\\
\text{Pattern }p \; ::= \; & \mathit{id} \\
&| \; (p,p)\\
\\
\text{Type }\tau \; ::= \; &nat \\
&| \; \mathit{bool} \\
&| \; \tau_{1} \rightarrow \tau_{2} \\
&| \; \tau_{1} \times \tau_{2} \\
&| \; \alpha \\
\end{align*}

\section{Type System}

We now formalize the Type System for MiniML. First, we introduce the concept of a type-scheme. The concept of a type-scheme, sometimes called polytype, introduces polymorphism by making use of the type variable $\alpha$ in the definition of $\tau$, and quantifying it with the $\forall$ quantifier. This allows any concrete types $\tau$ to 'match' to the type variable. For example, the identity function \inlinecode{id} is typed $id:\forall \alpha. \alpha \rightarrow \alpha$, thereby introducing parametrized polymorphism which enables one to use the same \inlinecode{id} function everywhere regardless of the arguments type.

This concept of a type-scheme will later be used to provide \todo{explain further}let-polymorphism.  Note that the definition of a Type-Scheme assures that the resulting type-scheme is in \emph{prenex normal form}, i.e. a string of quantifiers concluded by a quantifier-free ending.
\begin{align*}
\text{Type-Scheme } \sigma \; ::= \; &\tau \\
&| \; \forall \alpha . \sigma \\
\\
\intertext{A few relationships and properties can be defined over type-schemes and types: }
\\
\intertext{We also define the notion of a context. The context simply is a \textbf{set} allowing for lookups. It contains type assumptions, with representation $x:\sigma$, meaning $x$ has type $\sigma$, as well as mappings from module name to module definition.\endgraf
The $\Diamond \Gamma$ relation is a statement of well-formedness of a context $\Gamma$. A context is well-formed if the keyset of the lookup table it represents conforms to the standard notion of a set, meaning every key is used only once.}
\\
\text{Context }\Gamma ::=\; &\emptyset \\
&| \; \Gamma, (x:\sigma) \\
&| \; \Gamma, (name:\lbrace \Delta,d\rbrace^{name}\\
\\
\text{Well-formedness } ::=\;&\Diamond \Gamma
\\
\intertext{The following four relations are the typing judgements. They convey the meaning that an expression or other part of the syntax is well-typed in the context $\Gamma$. The typing of a module body and it's definitions generates a new typing context for the module. In this resulting context, the declarations must be well-typed.}
\text{ExpressionTyping } ::=\;&\Gamma \vdash e: \sigma \\
\text{ModuleTyping } ::= \; &\Gamma \vdash \mathit{Mod} \\
\text{DefinitionTyping } ::= \; &\Gamma \vdash d \rightarrow \Gamma' \\
\text{DeclarationTyping } ::= \;&\Gamma \vdash \Delta
\end{align*}

\subsection{Rules}
\begin{align*}
&\Gamma \vdash true : bool \tag{T-True} \\
&\Gamma \vdash false : bool \tag{T-False} \\
&\Gamma \vdash num \; n : nat \tag{T-Num} \\ \\
\tag{T-Mono}
&\frac{\sigma \geq \tau \longspace id:\sigma \in \Gamma}{\Gamma \vdash id:\tau}\\ \\
\tag{T-App}
&\frac{\Gamma \vdash e_{1}:\tau_{2} \rightarrow \tau_{1} \longspace \Gamma \vdash e_{2}:\tau_{2}}
{\Gamma \vdash e_{1}e_{2}:\tau_{1}} \\ \\
\tag{BuildContext1}
& id:\sigma \rightarrow \emptyset, (id:\sigma) \\ \\
\tag{BuildContext2}
&\frac{p_{1}:\sigma_{1} \rightarrow \Gamma_{1} \longspace p_{2}:\sigma_{2}\rightarrow \Gamma_{2}}
{(p_{1},p_{2}):\sigma_{1}\times \sigma_{2} \rightarrow \Gamma_{1}\cup \Gamma_{2}} \\ \\
\tag{T-Fun}
&\frac{p:\tau_{2} \rightarrow \Gamma_{2} \longspace \Gamma_{2} \cup \Gamma_{1} \vdash e:\tau_{1}}
{\Gamma_{1} \vdash \lambda(p:\tau).e:\tau_{2} \rightarrow \tau_{1}} \\ \\
\tag{T-IfThenElse}
&\frac{\Gamma \vdash e_{1}:bool \longspace \Gamma \vdash e_{2}:\tau \longspace \Gamma \vdash e_{3} : \tau}
{\Gamma \vdash if \; e_{1} \; then \; e_{2} \; else \; e_{3} : \tau} \\ \\
\tag{T-Pair}
&\frac{\Gamma \vdash e_{1}:\tau_{1} \longspace \Gamma \vdash e_{2}:\tau_{2}}
{\Gamma \vdash (e_{1},e_{2}) : \tau_{1}\times\tau_{2}} \\ \\
\tag{T-PairLeft}
&\frac{\Gamma \vdash p:\tau_{1}\times\tau_{2}}
{\Gamma \vdash \mathit{p.left} : \tau_{1}} \\
\\
\tag{T-PairRight}
&\frac{\Gamma \vdash p:\tau_{1}\times\tau_{2}}
{\Gamma \vdash \mathit{p.right} : \tau_{2}} \\
\\
\tag{T-Let}
&\frac{\Gamma \vdash e_{2}:\tau_{2} \;\;\; \sigma=gen(\Gamma,\tau)\;\;\;p:\sigma\rightarrow \Gamma_{2} \;\;\; \Gamma \cup \Gamma_{2} \vdash e_{1}:\tau}
{\Gamma \vdash let\;p\;=\;e_{2}\;in\;e_{1}:\tau} \\ \\
\tag{T-Letrec}
&\frac{\Gamma \vdash let\;p\;=\;\mathit{fix}\;(\lambda p.e_{2})\;in\;e_{1}:\tau}
{\Gamma \vdash letrec\;p\;=\;e_{2}\;in\;e_{1}:\tau} \\ \\
\tag{T-Fix}
&\frac{\Gamma \vdash e : \tau \rightarrow \tau}
{\Gamma \vdash \mathit{fix\;e} : \tau} \\
\displaybreak
\\
\tag{T-ModVarThis}
&\frac{\sigma \geq \tau \longspace this.id:\sigma \in \Gamma}
{\Gamma \vdash this.id : \tau} \\ 
\\
\tag{T-ModVarOther}
&\frac{\Gamma \vdash \lbrace\Delta,d\rbrace^{name} \longspace id:\tau \in \Delta}
{\Gamma \vdash name.id : \tau} \\ 
\\
\tag{T-Module}
&\frac{\emptyset \vdash d \rightarrow \Gamma' \longspace \Gamma' \vdash \Delta}
{\Gamma \vdash \lbrace\Delta,d\rbrace^{name}} \\
\\
\tag{T-ModInterface}
&\frac{(x:\tau) \in \Gamma \longspace \Gamma \vdash \Delta}
{\Gamma \vdash (x:\tau),\Delta}\\
\\
\tag{T-ModBody}
&\frac{ (x:\tau),\Gamma \vdash d \rightarrow \Gamma' \longspace \Gamma \vdash e:\tau}
{\Gamma \vdash (x=e:\tau),d \rightarrow (x:\tau),\Gamma'} \\
\\
\tag{T-EmptySet}
&\frac{\Diamond \Gamma}
{\Gamma \vdash \emptyset}
\end{align*}

\section{Operational semantics}
\begin{align*}
\text{Value }v ::=\;&\mathit{num\;n} \; | \; \mathit{true} \; | \; \mathit{false} \\
&| (v,v) \\
&| \lambda p.e\\
\\
\text{Environment } E\; ::= \;&\cdot \\
&|\;E:(\mathit{id}=v) \\
&|\;E:(\mathit{this.id}=v) \\ 
\\
\text{Evaluation } ::= &e \rightarrow e' \\
\end{align*}
\subsection{Rules}
\begin{align*}
\tag{E-IfTrue}
&if \; true  \; then \; e_{1} \; else \; e_{2} \rightarrow e_{1}\\
\tag{E-IfFalse}
&if \; false \; then \; e_{1} \; else \; e_{2} \rightarrow e_{2}\\ \\
\tag{E-IfThenElse}
&\frac{e_{1} \rightarrow e_{1}'}
{if \; e_{1} \; then \; e_{2} \; else \; e_{3} \rightarrow if \; e_{1}' \; then \; e_{2} \; else \; e_{3}}\\ \\
\tag{E-PairLeft}
&\frac{e_{1} \rightarrow e_{1}'}
{(e_{1},e_{2}) \rightarrow (e_{1}',e_{2})} \\ \\
\tag{E-PairRight}
&\frac{e_{2} \rightarrow e_{2}'}
{(e_{1},e_{2}) \rightarrow (e_{1},e_{2}')} \\ \\
\tag{E-Let}
&\frac{e_{1}\rightarrow e_{1}'}
{let \; p \; = \; e_{1} \; in \; e_{2} \rightarrow let \; x \; = \; e_{1}' \; in \; e_{2}}
\\ \\
\tag{E-LetV}
&let \; x \; = \; v \; in \; e \rightarrow [x \mapsto v]e \\ \\
\tag{E-LetRec}
&letrec\;p=\;e_{1} \; in \; e_{2} \rightarrow let \; p \; = fix(\lambda p.e_{1}) \; in \; e_{2} \\ \\ 
\tag{E-Fix}
&\frac{e\rightarrow e'}
{fix(e) \rightarrow fix(e')}\\ \\
\tag{E-FixRec}
&fix(\lambda(p.e)) \rightarrow [p \mapsto (fix (\lambda(p.e))]e \\ \\
\tag{E-PatternMatch}
&let \; (p_{1},p_{2}) \; = \; (e_{1},e_{2}) \; in \; e_{3} \rightarrow
let \; p_{1} \; = \; e_{1} \; in \;
(let \; p_{2}  \; = \; e_{2} \; in \; e_{3}) \\ \\
\tag{E-App1}
&\frac{e_{1} \rightarrow e_{1}'}
{e_{1} e_{2} \rightarrow e_{1}' e_{2}}\\ \\
\tag{E-App2}
&\frac{e_{2} \rightarrow e_{2}'}
{v\;e_{2} \rightarrow v\;e_{2}'}\\ \\
\tag{E-Lambda}
&(\lambda x . e) \; v \rightarrow [x \mapsto v]e \\ \\
\tag{E-MatchLambda}
&(\lambda (p_{1},p_{2}) . e_{3}) \; (e_{1},e_{2}) \rightarrow (\lambda p_{1}.(\lambda p_{2}.e_{3})\;e_{2})\; e_{1} \\
\displaybreak
\\
\tag{E-ModVar}
&\frac{\lbrace\Delta,d\rbrace^{M} \longspace (x=e':\tau) \in d \longspace e=[this.y\mapsto M.y]e'\;\forall (this.y \in e')}
{M.x \rightarrow e}
\end{align*}
\end{flushleft}
\end{document}