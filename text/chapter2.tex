\chapter{Formal Specification}
\label{chap:formalspecification}
In this chapter the source language, \MiniML, and the target language, LLVM IR, will be formally specified. 

First the syntax of \MiniML\ within which a program can be defined will be introduced.
Next, the typing rules that a correct program must adhere to is shown.
Lastly, the operational semantics determine what a correct program must do once it runs.

\section{MiniML}
\label{sec:MiniMLFormalSpecification}
\subsection{Syntax}
\label{sec:ch2syntax}
First this section introduce the syntax of the \MiniML\ language, as seen in \myref{fig}{fig:CoreSyntax}, \myref{fig}{fig:ModuleSyntax} and \myref{fig}{fig:ProgramSyntax}.
Like ML, the \MiniML\ syntax is composed of three parts~\cite{Milner:1997:DSM:549659}: the \emph{Core} language, a \emph{Module} language, and the concept of a \emph{Program}. 
The three languages, \emph{Core}, \emph{Module} and \emph{Program} each have their corresponding valid \emph{expression}s.
The division between \emph{Core} and \emph{Module} mostly correlates to the concepts of `programming in the small' and `programming in the large'~\cite{Milner:1997:DSM:549659,DeRemer:1975:PLV:390016.808431} respectively.
This separation of programming in the large and programming in the small aims to help programmers to introduce the right degree of modularity in their software.

\subsubsection{Core language}
The \emph{Core} mainly consists of \emph{value expressions} \cmath{e}. 
These express the manipulation of values and execution of functions to implement small algorithms or control logic.
Every value expression \cmath{e} needs to have a corresponding type \cmath{\tau}, otherwise the expression is not \emph{sound}.
The \emph{Core} language syntax is shown in \myref{fig}{fig:CoreSyntax}.

\input{coresyntax1}

\subsubsection{Module language}
The \emph{Module} language uses \emph{module expressions} \cmath{me} to specify how the small parts of \emph{Core} expressions can be `glued together' or \emph{composed} into larger, working programs.
Its syntax is shown in \myref{fig}{fig:ModuleSyntax}.

The \emph{Module} language brings encapsulation and namespaces to \MiniML.
The \emph{Module} language does this by introducing the concept of a \emph{structure}, as was informally explained in \myref{sec}{sec:MiniML}.
A structure is defined using a \lsttext{struct} expression, and bound to an identifier \cmath{StrId} using the \lsttext{structure} expression.
It consists of a body of definitions which is denoted in the syntax as $\overline{\mathit{\delta}}$, using the bar notation for lists\footnote{
The bar notation uses $\emptyset$ as the empty set and the comma (,) as the prepend operator.
For example: $\overline{\mathit{\delta}}$ could be the empty set $\emptyset$ or it could be $id = e:\tau, \overline{\delta}$.}.
In its body, a structure \cmath{StrId} can bind values \cmath{id} to a value expression \cmath{e}, or can define a new type \cmath{t}.

Just as types in the \emph{Core} language limit the number of valid or \emph{sound} value expressions, signatures restrict the number of well-typed module expressions.
Signatures are named and bound to their identifier using the \lsttext{signature} expression. 
They are defined using the \lsttext{sig} expression, and their body consists of abstract type definitions, type synonyms and value declarations.

A structure can be ascribed a signature using \emph{transparant} ($:$) or \emph{opaque} ($:>$) ascription.
\begin{description}
\item[Transparant ascription] Transparant ascription \cmath{StrId : SigId} lets the implementation of type definitions in the underlying structure \cmath{StrId} propagate through, while hiding from external view any values that were not declared in the signature \cmath{SigId}.
\item[Opaque ascription] Opaque ascription \cmath{StrId :> SigId} restricts the external view of the structure to the values and types declared inside the signature \cmath{SigId}.
If a type \cmath{t} is declared abstract in \cmath{SigId}, its implementation is not known to any code not local to the structure.
\end{description}

In order to obtain a \emph{more simple} language to study, \MiniML\ signatures restrict their declarations to a subset \cmath{T} of the \emph{Core} types \cmath{\tau}. 
The subset \cmath{T} contains only \emph{opaque} types defined by structures, the int and function types.
As a result, any value that is accessible from outside the structure itself can only get parameters and return values of type \lsttext{int}, of an opaque type or of a function combination of those types.

This results in arrays \cmath{[\tau]} and pairs \cmath{\tau_{1} \times \tau_{2}} not being primitive types for module expressions.
Only within a structure can a value be treated as an array or pair, if the value is of an opaque type that is defined:
\begin{enumerate}
\item Within the same structure.
\item With an implementation containing the array or pair type.
\end{enumerate}

\input{modulesyntax1}

\subsubsection{Program}
A \MiniML\ program consists of a set of \emph{Module expressions}.
%, denoted as \cmath{\overline{\mathit{me}}}. 
It is then concluded by a single naked value expression \cmath{e}, functioning as the main entry point of the program.
This description of a program allows us to first specify a set of signatures as well as a set of structures conforming to those signatures.
The syntax of a Program is shown in \myref{fig}{fig:ProgramSyntax}

\input{programsyntax}

%A signature $\Sigma$ is a module type and is represented by a list of \emph{declarations}. A declaration $\Delta$ specifies the type of an value identifier or the signature of a module identifier.
%\\[2ex] 
%A module can be seen as a special case of functors. A module specifies a signature and module body and is uniquely identified with an identifier $M_{i}$. The module body is represented as a list of definitions $\overline{d}$. A module $M_{i}$ with body $\overline{d}$ conforms to a signature $S_{i}$ if every identifier in $S_{i}$ has a definition in the module body, and its typing does not violate the one specified in the signature.
%\\[2ex]
%Functors $F_{i}$, presented as a generalization of modules, specify \todo{Is it always possible to specify the interface of a module? In our simple system, yes, There can be no problem with opaque types since we don't support them.} their own signature, $S_{i}$, as well as a set of signatures upon which it depends, $\overline{S_{n}}$. It then specifies a functor body in which those modules can be used. The functor can be given a set of modules that conform to the dependent signatures. We say the functor is applied to a set of modules. The result of this application behaves as a module that conforms to the interface $S_{i}$ that the functor specified for itself.

%\subsubsection{Syntax example}
%We now give an example of a syntactically correct \mbox{MiniML} program.

%\begin{figure}[!htbp]
%\begin{verbatim}
%test
%\end{verbatim}
%\caption{Syntax example}
%\label{code:SyntaxExample}
%\end{figure}

\subsection{Type system}
\label{sec:MLTypeSystem}
Having defined the syntax for \MiniML\ and its parts, this section formalizes the static semantics, also called its \emph{type system}.
As stated in \myref{sec}{sec:ch2syntax}, types and signatures restrict the world of possible programs to those that consist of \emph{sound} or \emph{well-typed} module and value expressions.
It is the type system that formalizes when exactly a module expression \cmath{me} is of the correct signature \cmath{SigId}, or a value expression \cmath{e} of the correct type \cmath{\tau}.

The \MiniML\ language type system is based on the Hindley-Milner type system~\cite{Hindley1969,Milner78atheory}.
While the Standard ML implementation provides type inference using the Damas-Milner type inference algorithm~\cite{Damas:1982:PTF:582153.582176}, the \MiniML\ language assumes type annotations are available, written by the programmer.
This is by no means a fundamental restriction, the \MiniML\ language does not deviate from ML enough to prohibit the use of type inference.

\subsubsection{Type judgements and Contexts}
The type system validates programs by checking that a program \cmath{P} consists solely of \emph{sound} or \emph{well-typed} module expressions \cmath{me} and value expressions \cmath{e}.
%This checking will be done using rules that describe when a single expression \cmath{e} or \cmath{me} is well-typed.
%Formally, the type checker will perform typing judgements
This checking is done using \emph{typing judgements} that state whether a single expression \cmath{e} or \cmath{me} is well-typed.
The typing judgement of an expression \cmath{e} is symbolized by: 
\[\vdash e:\tau\]

The well-typedness of an expression \cmath{e} however does not depend on the expression \cmath{e} in isolation.
Instead, parts of the program processed earlier by the type checker can have an influence on the well-typedness of the single expression \cmath{e}.
This dependence of an expression \cmath{e} on earlier expressions is formalized using the idea of a \emph{context} $\Gamma$~\cite{Pierce}. 

This context keeps track of the type assumptions and type definitions as well as structure and signature definitions made earlier.
It stores the facts that the type system has already established to be true.
The structure of a context $Gamma$ is shown in \myref{fig}{fig:MiniMLContexts}.

To access the mappings from \cmath{StrId} or \cmath{SigId} to its signature, its definitions or its declarations, the context allows for projections. For example $\Gamma[\mathit{StrId}].\overline{d}$ will look up the mapping $(\mathit{StrId} \mapsto \lbrace \Sigma,\overline{d}\rbrace)$ in $\Gamma$ and project this to the $\overline{d}$ specified in the mapping. A lookup will \emph{fail} if the identifier has no mapping in the context.

\begin{figure}[!htb]
\begin{align*}
\begin{aligned}
\text{Context }\\
\Gamma ::=\; &\emptyset     & \expl{(empty context)}\\
&| \; (\mathit{id}:\sigma),\Gamma          & \expl{(identifier type assumption)}\\
&| \; (t = \tau), \Gamma                   & \expl{(type definition)}\\
&| \; (\mathit{StrId} \mapsto \lbrace \Sigma,\overline{d}\rbrace), \Gamma 
                                           & \expl{(structure definition)}\\
% &| \; (F_{i} \mapsto \lbrace \Sigma, \overline{\Sigma_{n}}, \overline{d} \rbrace), \Gamma \\
&| \; (\mathit{SigId} \mapsto \Sigma), \Gamma
                                           & \expl{(signature definition)}
\end{aligned}
\end{align*}
\caption[Contexts]{Contexts in the MiniML type system.}
\label{fig:MiniMLContexts}
\end{figure}

With the addition of contexts, type judgements become relations between a context $\Gamma$ and expressions \cmath{me} or \cmath{e}, formalized as $\Gamma \vdash e:\tau$.
This states that an expression or other part of the syntax is well-typed within the specified context $\Gamma$.

When typing judgement of a structure and its definitions occurs, the type system returns a new typing context $\Gamma'$ to perform subsequent typing judgements.
In this resulting context, all subsequent expressions must be well-typed.

The $\Gamma \vdash \Diamond$ judgement is a statement of well-formedness of a context $\Gamma$. 
A context is well-formed if the keyset of the lookup table it represents conforms to the standard notion of a set, meaning every key is used only once.
This makes it invalid to rebind structures or signatures.

The possible typing judgements can be seen in \myref{fig}{fig:TypingJudgements}.

\begin{figure}[!htb]
\begin{align*}
\text{ExpressionTyping } ::=\;&\Gamma \vdash e: \sigma \\
\text{ModuleTyping } ::= \; &\Gamma \vdash \mathit{me} \rightarrow \Gamma' \\
%\mathit{StrId}:\mathit{SigId} \rightarrow \Gamma' \\
%\text{DefinitionTyping } ::= \; &\Gamma \vdash d \rightarrow \Gamma' \\
%\text{DeclarationTyping } ::= \;&\Gamma \vdash \Delta \\
\text{Well-formedness } ::=\;&\Gamma \vdash \Diamond
\end{align*}
\caption[Typing Judgements]{Typing judgements in the MiniML type system.}
\label{fig:TypingJudgements}
\end{figure}

\subsubsection{Type-schemes}
The typing judgements, in their contexts, do not type an expression using a type $\tau$. Instead they use an extension on the regular type $\tau$ called a type-scheme $\sigma$.
The concept of a type-scheme is shown in \myref{fig}{fig:MiniMLTypeSchemes}.
%First, the concept of a type-scheme is introduced, as shown in \myref{fig}{fig:MiniMLTypeSchemes}.

\begin{figure}[!htb]
\begin{align*}
%\begin{aligned}
%\text{Context }\Gamma ::=\; &\emptyset \\
%&| \; (\mathit{id}:\sigma),\Gamma \\
%&| \; (\mathit{StrId} \mapsto \lbrace \mathit{SigId},\overline{d}\rbrace), \Gamma \\
%% &| \; (F_{i} \mapsto \lbrace \Sigma, \overline{\Sigma_{n}}, \overline{d} \rbrace), \Gamma \\
%&| \; (\mathit{SigId} \mapsto \Sigma), \Gamma
%\end{aligned}
%\begin{aligned}
%\longspace
%\end{aligned}
\begin{aligned}
\text{Type-Scheme } \sigma \; ::= \; &\tau \\
&| \; \forall \alpha . \sigma
\end{aligned}
\end{align*}
\caption[Type Schemes]{Type-schemes in the MiniML type system.}
\label{fig:MiniMLTypeSchemes}
\end{figure}

A type-scheme, sometimes called polytype, introduces a type of polymorphism called let-poly\-morphism~\cite{Pierce} by taking a type variable $\alpha$ in the definition of $\tau$, and quantifying it with the universal quantifier $\forall$.
This allows any concrete types $\tau$ to `match' to the type variable, whereas an unquantified type variable $a$ is unique and only matches itself.
Note that the definition of a type-scheme assures that the resulting type-scheme is in \emph{prenex normal form}, i.e. a string of quantifiers concluded by a quantifier-free ending.

\begin{description}
\item[Free variables]
Looking at a type-scheme $\sigma$ in \myref{fig}{fig:MiniMLTypeSchemes}, it is clear that some of the type variables $\alpha$ are quantified, and others are not.
Those type variables that are not quantified are called `free' variables.
The set of free variables within a type-scheme $\sigma$ is denoted by the predicate\cmath{\ free(\sigma)}, and the value of this predicate is computed as follows:

\begin{align*}
\begin{aligned}
\cmath{free(int)} &= \cmath{\emptyset}\\
\cmath{free(StrId.t\ \overline{\tau})} &= \cmath{\bigcup_{\tau \in \overline{\tau}} free(\tau)}\\
\cmath{free(\alpha)} &= \cmath{\{\alpha\}}\\
\cmath{free([\tau])} &= \cmath{free(\tau)}\\
\cmath{free(\tau_{1} \times \tau_{2})} &= \cmath{free(\tau_{1}) \cup free(\tau_{2})} \\
\cmath{free(\overline{\tau_{1}} \rightarrow \tau_{2} )} &= \cmath{free(\tau_{2}) \cup \bigcup_{\tau \in \overline{\tau_{1}}} free(\tau)}
\end{aligned}
\end{align*}
\end{description}

The type-scheme introduces polymorphism because it possible for two type-schemes to match, even if they are not exactly the same.
For example, the identity function \inlinecode{id} is typed $id:\forall \alpha. \alpha \rightarrow \alpha$.
Because any type can be accepted as being of type $\alpha$ one can use the same \inlinecode{id} function everywhere regardless of the arguments type.

The way that two type-schemes match, even if they are not the same, is given by the two relations called \emph{specialization}/\emph{generalization}.
Instinctively, the relations corresponds to the idea that a type variable $\alpha$ can be exchanged for any type $\tau$, but that this must happen in a consistent way.

%Because it is clear from the definition of a type-scheme in \myref{fig}{fig:MiniMLTypeSchemes} 

%\\[2ex]
%Our type system will also need to keep track of the type assumptions and the module, functor and signature definitions. This represents the notion of a \emph{context}. It is in this context that typing will happen. While type checking, the context is what the type checker uses to keep track of the facts it already knows.
%\\[2ex]
%To access mappings from these contexts, we will introduce projections. For example $\Gamma[M_{i}].\overline{d}$ will look up the mapping $(M_{i} \mapsto \lbrace S,\overline{d}\rbrace)$ in $\Gamma$ and project this to the $\overline{d}$ specified in the mapping. A lookup will \emph{fail} if the identifier has no mapping in the context.

\begin{description}
\item[Type-scheme specialization:]
The specialization relation $\sigma_{1} \geq \sigma_{2}$ expresses that $\sigma_{2}$ is more specialised than $\sigma_{1}$. This means that the following rule\footnote{A rule uses the notation \cmath{\frac{premise}{conclusion}} where \cmath{premise} is the set of conditions for that must be hold before the conclusion holds.} determines the specialization relation.
% $\sigma_{2}$ can be expressed as $\forall \beta_{i}...\beta_{m}.\sigma_{2}'$ and $\sigma_{1}$ as $\forall \alpha_{1}...\forall \alpha_{n}.\sigma_{1}'$, $\sigma_{2}$ is more specialised than $\sigma_{1}$ iff $\sigma_{2}'=[\alpha_{i} \mapsto \sigma_{i}]\sigma_{1}'$ and $\beta_{i} \in free(\sigma_{1})$. In other words, 
%

\[
\tag{specialization}
\frac{\tau_{2}=[\alpha_{i} \mapsto \tau_{i}]\tau_{1} \longspace \beta_{i} \not\in\mathit{free(\forall\alpha_{1}...\forall \alpha_{n}.\tau_{1})}}
{\forall\alpha_{1}...\forall\alpha_{n}.\tau_{1}\geq \forall \beta_{i}...\forall \beta_{m}\tau_{2}'}
\]

In other words, a more specialized type-scheme can be obtained by consistently replacing quantified type variables $\alpha_{i}$ in the more general type-scheme by a type $\tau_{i}$.
This type $\tau_{i}$ is allowed to contain type variables itself.
However, no type variable that was free in the more general type-scheme can become quantified in the more specialized type-scheme.

The first condition gives one the possibility to specify the type of a type variable. This second condition forbids one to \emph{rescope} a type variable in the process.

\item[Type-scheme generalization:]
Type-scheme generalization is the opposite process of type-scheme specialization. However, whereas specialization can be expressed independent of the context, whether or not one is allowed to generalize, is dependent on the context. Generalisation allows one to quantify an unquantified variable, as long as it does not appear unquantified in any type assumption already made in the current context.
\end{description}

\[
\tag{generalization}
\frac{\Gamma \vdash e:\sigma \longspace \alpha \not\in \mathit{free(\Gamma)}}{\Gamma \vdash e : \forall \alpha . \sigma}
\]

\subsubsection{Signature Matching}
\label{sec:StructuralTyping}
Just like set of valid value expressions \cmath{e} is restricted by the type system using types, the set of valid structure expressions is restricted using \emph{signature ascription}. As mentioned earlier, these ascriptions happen either \emph{transparant} or \emph{opaque}.
This subsection explains how a structure expression is restricted by a signature using the \emph{signature matching} relation.

Every structure expression has a corresponding \emph{principal signature}, symbolized by \cmath{PS(\overline{d})}, where \cmath{\overline{d}} is the body of the \lsttext{struct} expression.
The principal signature of a structure expression consists of all type specifications and all values with their corresponding types.

When a structure is ascribed a signature, its principal signature must \emph{match} with the ascribed signature.
In this matching, the principal signature is called the \emph{candidate}, while the ascribed signature is called the \emph{target}.
The signature matching relation is formalized using $\mathit{\Sigma_{target}}\succeq\mathit{\Sigma_{candidate}}$.

For a \emph{candidate} signature to match its \emph{target}, any value or type specification in the \emph{target} signature must have an equivalent specification in the \emph{candidate} signature.
\begin{enumerate}
\item For types, this means that for each type in the \emph{target}, there is a type in the \emph{candidate} with the same name.
If \emph{target} carries a definition for the type, \emph{candidate} must provide the same definition.
\item For values, this means that for each value in the \emph{target}, there exists a value with the same name in the \emph{candidate} whose type is at least as general as the corresponding type in the \emph{target}.
\end{enumerate}

These signature matching constraints allow the expression of a structure to have a principal signature that is more broad than its ascribed signature.
It can define more types or values, and provide existing values with more general types.
These types and values can be used locally within the structure, but not in non-local code.

The effective signature of a structure \cmath{StrId} with body \cmath{\overline{d}} is denoted with \cmath{ES(\overline{d})}, which corresponds to
\begin{itemize}
\item all type definitions present in \cmath{\overline{d}}, and the value declarations present in \cmath{SigId} $\Leftrightarrow$ \cmath{StrId} was transparantly ascribed with signature \cmath{SigId}.
\item The signature bound to \cmath{SigId} $\Leftrightarrow$ \cmath{StrId} was opaquely ascribed with signature \cmath{SigId}.
\end{itemize}

Type definitions and value declarations in a signature can contain type variables.
However, all type variables are assumed be quantified universally.
This means for example that a type definition written as $type\ \overline{\alpha}\ t = \tau$ contained in $\overline{d}$ results in a type definition $t\ \overline{\alpha} = \forall \alpha_{1}...\forall \alpha_{n}.\tau$ as an element of \cmath{ES(\overline{d})}.
\\[1em]
Note that signatures are in fact a set of type bindings and type definitions.
Since a context can contain type bindings and type definitions as well, it is possible to take the union of a signature and a context $\Gamma$.


\subsubsection{Type Rules}
Using the type judgements specified earlier, it is possible to create a set of rules that specify when an expression \cmath{e} or \cmath{me} is valid.
Some expressions are well-typed unconditionally and in any context, for example rule T-Num in the typing rules in \myref{fig}{fig:TypeRulesCore}.
Others are only typed correctly if for example a certain subexpression is correctly typed. In this case, the typing rule becomes of the form shown in rule T-App.

The typing rules are divided in rules concerning the core language in \myref{fig}{fig:TypeRulesCore}, rules concerning the \emph{Module} language in \myref{fig}{fig:TypeRulesModule} and rules for the \emph{Program} language in \myref{fig}{fig:TypeRulesProgram}.
%\clearpage
\input{typerules1}

\clearpage
\subsection{Operational semantics}
\label{sec:MLOperationalSemantics}
\begin{figure}[htb]
\begin{align*}
\text{Value }v ::=\;&\mathit{num\;n} \\ %\; \mathit{true} \; | \; \mathit{false} \\
&|\ (v,v) \\
&|\ [v]
%&|\ \lambda p.e\\
\\
\text{Module Table } T\; ::= \;&\emptyset \\
&| \; (\mathit{StrId} \mapsto %\lbrace \mathit{SigId},
\overline{d}
%\rbrace
), T \\
%&| \; (F_{i} \mapsto \lbrace \Sigma, \overline{\Sigma_{n}}, \overline{d} \rbrace), T \\
%&| \; (\mathit{SigId} \mapsto \Sigma), T\\
\\
\text{Evaluation } ::= & T \vdash P \rightarrow T \vdash P' \\
\end{align*}
\caption[Operational Semantic Entities]{Relations and entities of the operational semantics.\label{fig:MiniMLOperationalSemanticEntitiesAndRelations}}
\end{figure}

The operational semantics defines a module table T, and the evaluation relation, shown in \myref{fig}{fig:MiniMLOperationalSemanticEntitiesAndRelations}.
This module table contains mappings from the %, module and functor identifiers to their definition and and the evaluation relation. 
module identifiers to their definition. 

The module table T allows looking up the definition behind a certain identifier and accessing a certain part of it using projection. $T[\mathit{StrId}].\mathit{SigId}$ will give access to the \cmath{SigId} in the definition of \cmath{StrId}. 

The evaluation relation allows the evaluation of a program $P$, which consists of expressions $e$ and module expressions \cmath{me}, to a (simpler) Program $P'$, while potentially making a lookup in T.

\subsubsection{Rules}
In \myref{fig}{fig:MiniMLOperationalSemantics}, the evaluation rules of a \MiniML\ program are shown.
It first collects evaluates module expressions, skipping \lsttext{signature}-bindings and adding \lsttext{structure}-bindings to the table T.
When a field inside a structure is referenced, the reference can be evaluated to its definition, with the exception that all references to fields \cmath{y} defined within the module are correctly substituted with \cmath{StrId.y}.

\input{operationalsemantics}

%\todo{How to express the substitution of all references to argument placeholder module names to the modules names given at execution}
%\todo{provide a desugar function}
%\end{flushleft}

\clearpage
\section{LLVM Intermediate Representation}
The LLVM Intermediate Representation is a language very reminiscent of assembly.
In contrast to assembly, it is strongly typed, and operates with a slightly higher level of abstraction.

This section largely builds on the work of Jianzhou Zhao et al. in formalizing the \LLVMIR~\cite{Zhao:2012:FLI:2103656.2103709}.
Their paper formalizes a reduced part of the LLVM IR in order to create mathematically verified program transformations.
It provides a language syntax as well as static and dynamic semantics.

\newcommand{\kw}[1]{\text{\lsttext{#1}}}
\subsection{Syntax}
In \myref{fig}{fig:LLVMSyntax}, their reduced syntax of LLVM IR is given, with some small changes.\begin{figure}[!htb]
\begin{align*}
\begin{aligned}
\text{Modules }\mathit{mod} ::= &\overline{\mathit{prod}} \\
\text{Products }prod ::= & \mathit{id =\ }\kw{global}\ \mathit{typ}\ \mathit{const}\ \mathit{align}\ |\ \kw{define} \mathit{\ typ\ id(\overline{arg})\{\overline{b}\}}\\
&|\ \kw{declare} \mathit{\ typ\ id(\overline{arg})} \\
\text{Types } \mathit{typ} ::= &\kw{i} \mathit{sz\ |\ } \kw{void} \mathit{\ |\ typ*\ |\ \left[sz \times typ\right]\ |\ \lbrace\ \overline{typ_{j}}^{j}\ \rbrace\ |\ typ\ \overline{typ_{j}}^{j}\ \rbrace\ | id} \\
\text{Values } \mathit{val} ::= &\mathit{ id\ |\ cnst} \\
\text{Binops } \mathit{bop} ::= &\kw{add} \ |\ \kw{sub}\ |\ \kw{mul}\ |\ \kw{udiv}\ |\ \kw{sdiv}\ |\ \kw{urem}\ |\ \kw{srem}\ |\ \kw{shl}\ |\ \kw{lshr}\ |\ \kw{and}\\
&|\ \kw{or}\ |\ \kw{xor} \\
\text{Float Ops } \mathit{fbop} ::= &\mathit{fadd \ |\ fsub \ |\ fmul \ |\ fdiv \ |\ frem} \\
\text{Extension } \mathit{eop} ::= &\mathit{zext \ |\ sext \ |\ fpext} \\
\text{Cast op } \mathit{cop} ::= &\mathit{fptoui \ |\ ptrtoint \ |\ inttoptr \ |\ bitcast} \\
\text{Trunc op } \mathit{trop} ::= &\mathit{trunc_{int} \ |\ trunc_{fp}} \\
%
%
\text{Constants } \mathit{cnst} ::= &\mathit{isz\ Int\ |\ fp\ Float\ |\ typ\ *\ id\ |\ (typ*)\ null\ |\ typ\ zeroinitializer} \\
&\mathit{|\ typ\overline{[cnst_{j}]}^{j}\ |\ \overline{\lbrace cnst_{j} \rbrace}^{j}\ |\ typ\ undef\ |\ bop\ cnst_{1}\ cnst_{2}} \\
&\mathit{|\ fbop\ cnst_{1}\ cnst_{2}\ |\ trop\ cnst\ to\ typ\ |\ eop\ cnst\ to\ typ}\\
&\mathit{|\ cop\ cnst\ to\ typ\ |\ getelementptr\ cnst\ \overline{cst_{j}}^{j}}\\
&\mathit{|\ select\ cnst_{0}\ cnst_{1}\ cnst_{2}\ |\ icmp\ cond\ cnst_{1}\ cnst_{2}}\\
&\mathit{|\ fcmp\ fcond\ cnst_{1}\ cnst_{2}}\\
%
%
\text{Blocks } \mathit{b} ::= &\mathit{l\ \overline{\phi}\ \overline{c}\ tmn} \\
\phi\ \text{nodes } \phi ::= &\mathit{id} \text{ = phi } \mathit{typ \overline{[val_{j} , l_{j} ]}^{j}}\\
%\phi\ \text{nodes} \mathit{\phi} ::= &\mathit{id\ =\ } \text{phi} typ [val_{j} , l_{j} ] \\
\text{Tmns } \mathit{tmn} ::= &\mathit{br\ val\ l_{1}\ l_{2} \ |\ br\ l \ |\ ret\ typ\ val\ |\ ret\ void\ |\ unreachable} \\
\text{Commands } \mathit{c} ::= &\mathit{id\ =\ bop(int\ sz)\ val_{1}\ val_{2}\ |\ id\ =\ fbop\ fp\ val_{1}\ val_{2}}\\
&\mathit{|\ id\ =\ load(typ*)\ val_{1}\ align\ |\ store\ typ\ val_{1}\ val_{2}\ align}\\
&\mathit{|\ id\ =\ malloc\ typ\ val\ align\ |\ free(typ * )\ val}\\
&\mathit{|\ id\ =\ alloca\ typ\ val\ align\ |\ id\ =\ trop\ typ_{1}\ val\ to\ typ_{2}}\\
&\mathit{|\ id\ =\ eop\ typ_{1}\ val\ to\ typ_{2}\ |\ id\ =\ cop\ typ_{1}\ val\ to\ typ_{2}}\\
&\mathit{|\ id\ =\ icmp\ cond\ typ\ val_{1}\ val_{2}\ |\ id\ =\ select\ val0\ typ\ val_{1}\ val_{2}\ }\\
&\mathit{|\ id\ =\ fcmp\ fcond\ fp\ val_{1}\ val_{2}\ |\ option\ id\ =\ call\ typ_{0}\ val_{0}\ \overline{param}}\\
&\mathit{|\ id\ =\ getelementptr(typ*)\ val\ \overline{val_{j}}^{j}}
%\text{} \mathit{} ::= &\mathit{} \\
%\text{} \mathit{} ::= &\mathit{} \\
%\text{} \mathit{} ::= &\mathit{} \\
%\text{} \mathit{} ::= &\mathit{} \\
\end{aligned}
\end{align*}
\caption[Syntax: LLVM]{The reduced LLVM Syntax, largely built upon Jianzhou Zhao et al. \cite{Zhao:2012:FLI:2103656.2103709} \label{fig:LLVMSyntax}}
\end{figure}

The syntax shows the idea of a module, which corresponds to a unit that can be compiled separately from other modules.
Later, all modules are put together in a stage called \emph{linking}.

A module consists, among others, of definitions and declarations:
\begin{description}
\item[Definitions] are named values, whose name is unique within a module, defined within the module itself.
They can be defined with linkage type `private', which means that the linkage phase will not allow other modules to address these values.
\item[Declarations] represent dependencies on values defined externally.
They can then be used within the module.
Later, the linking phase will couple this declaration to an implementation provided by a different module.
\end{description}
\clearpage
\section{Formalized Compiler}
\label{sec:formalizedcompiler}
This section formalizes the secure compilation process.
The compilation process is a translation of a program \cmath{P} expressed in \MiniML\ to a program written in the \LLVMIR.
It is symbolized as the translation function $\compile{\bullet}$.


The compiler formalized here aims to be 
%part of
a secure compiler, it takes a set of module expressions and translates them to \LLVMIR\
%in a fully abstract~\cite{Abadi,Agten:2012:SCM:2354412.2355247} manner.
to allow for fully abstract~\cite{Abadi,Agten:2012:SCM:2354412.2355247} binary protected modules or \emph{SPM}s.
As explained in \myref{sec}{sec:},\todo{refer to introduction, to be written} fully abstract compilation uses the notion of \emph{contextual equivalence}~($\simeq$)~\cite{Agten:2012:SCM:2354412.2355247}.

These requirements of the compiler are interpreted as follows: The program \cmath{P} given to the compiler is a set of module expressions \cmath{me} that represent the secure code.
This set of module expressions \cmath{me} is compiled separately from any other, insecure code to an \LLVMIR\ program \cmath{\compiled{P}} which can be processed to a fully abstract \emph{SPM}.
%This set of module expressions \cmath{me} has to be compiled in a fully abstract way to \LLVMIR\ \cmath{P\downarrow}.
This means that if this \cmath{\compiled{P}} is later compiled further to an object file and linked together with a context \cmath{C}, there exists no context \cmath{C} that can tell from \cmath{\compiled{P}} from the compilation \cmath{\compiled{P'}}, where \cmath{\compiled{P'}} is the compilation result of a source-level contextually equivalent \MiniML\ program \cmath{P'}.

The result of the translation $\compile{\bullet}$ is expected to run as an \emph{SPM} on a low-level machine model as used in \cite{Agten:2012:SCM:2354412.2355247,Patrignani}.
This model provides program counter based access control, or \emph{PCBAC}\footnote{https://distrinet.cs.kuleuven.be/software/pcbac/\#platforms}.
The semantics of this program counter based access control are given in \myref{fig}{fig:PCBAC}.

\begin{figure}[htb]
    \centering
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		From \textbackslash To & \multicolumn{3}{c|}{Protected} & Unprotected \\
		& Entry Point & Code & Data & \\ \hline
		Protected & r x & r x & r w & r w x \\ \hline
		Unprotected & x & & & r w x \\ \hline
	\end{tabular}
    \caption[PCBAC Semantics]{Program counter based access control semantics as specified in Agten et al.\cite{Agten:2012:SCM:2354412.2355247}. \label{fig:PCBAC}}
\end{figure}

The result of the translation will be loaded within the protected code, and its data section will correspond to the protected data section of the pcbac model.
The formalization of the translation function \cmath{\compile{\bullet}} will provide clear annotations for additional actions that can not be specified within the \LLVMIR\ language.
These are actions such as the specification of entry points in the \emph{SPM} layout or the clearing of low-level registers and flags.

\subsection{Formalization}
First, all module expressions are sorted based on the name used in the binding.
Two programs with differently ordered module expressions \cmath{me} are contextually equivalent as long as long as no module expression \cmath{me} has unresolved dependencies on other module expressions when it is bound.
Sorting module expressions based on the name used in the binding makes sure that all \MiniML\ programs that provide the same set of bindings result in an \LLVMIR\ program with the corresponding bindings happening in the same order.

\input{formalization}

The code of the \lsttext{@mask}, \lsttext{@unmask} and \lsttext{@unmasktype} functions is given in \myref{lst}{lst:maskcode} in App. \ref{App:LLVMCode}. 
It gives a more naive implementation of \lsttext{@mask}, \lsttext{@unmask} and \lsttext{@unmasktype} functions using linked lists.

The translation of an expression poses no additional security concerns and is compiled to the function or value body.
Since \myref{sec}{sec:DefinitionOfCompilation} states the module expressions making up the \emph{SPM} are compiled in a separate file, before the context, nothing in these expressions can depend on things defined in insecure code.
This is not a fundamental restriction, it is possible to have these expressions depend on outside code by either:
\begin{itemize}
\item Allowing dependencies on the context to be hardcoded, which would correspond to the high-level \MiniML\ interpretation that the contex split up in two parts.
The first part is compiled before the file containing the secure module expressions, the second part after the secure module expressions.

The resulting security issues could by resolved by introducing a returnback entry point into the \emph{SPM}, as described by Agten et al.\cite{Agten:2012:SCM:2354412.2355247}.
\item Adding the functionality of callbacks to the language, using closures.
\end{itemize}

\section{Conclusion}
This chapter formally specified a simple version of the \MiniML\ source-language and the \LLVMIR\ target-language.
It then gave a formal representation of the secure compiler from \MiniML\ to \LLVMIR.

The \MiniML\ language as sketched here does not yet contain the more advanced concepts found in MLs well-known module language.
The next chapter aims to rectify this by introducing both \emph{higher-order functions} and \emph{functors} to the \MiniML\ language.

% some of the more advanced concepts within ML to \MiniML.

%\mathit{id}\ \overline{x}\ =e:\tau

%\begin{align*}
%\begin{aligned}
%\compile{\overline{me}} \makes \compile{sort(\overline{me})}\\
%%\intertext{
%%Next, all module expressions can be translated individually.
%%The signature \cmath{SigId} used in the ascription of \cmath{StrId} is saved:
%%}
%\compile{me, \overline{me}} \makes \compile{me};\compile{\overline{me}}\\
%\compile{StrId:SigId = \overline{d}} \makes \compile{\overline{d}}^{\mathit{SigId}}\\
%\intertext{
%All fields in a module are sorted alphabetically as well. 
%This is done for the same reason as the sorting of module expressions: two \MiniML\ programs \cmath{P} differing only in the order of their fields are contextually equivalent.
%To prevent leakage of this ordering in the target-level, outputting the fields in the target language happens in a fixed ordering.
%}
%\compile{\mathit{\overline{d}}}^{\mathit{SigId}} \makes \compile{\mathit{sort(\overline{d})}}^{\mathit{SigId}} &\\
%\intertext{
%The compiler can now continue by translating the elements specified within the module expression.
%Every definition is translated separately.
%}
%\compile{\overline{d}}^{\mathit{SigId}} \makes \compile{d}^{\mathit{SigId}};\compile{\overline{d}}^{\mathit{SigId}} &\\
%\intertext{
%The translation of a definition depends on a number of things.
%\begin{itemize}
%\item Whether the definition is that of a type or that of a field.
%%The definition of a type is not translated to llvm.
%\item Whether or not the value is local to the structure \cmath{StrId}.
%This depends on the value being declared in the signature \cmath{SigId}.
%\end{itemize}
%}
%\compile{\text{\lsttext{val} } id = e : \tau}^{\mathit{SigId}} \makes \text{\lsttext{define private i32 @}}id\text{\lsttext{_internal()\{}} \compile{e}^{\mathit{SigId}} \kw{\}} &\\
%&\text{\lsttext{define i32 @}}id\text{\lsttext{()\{}} \\
%&\text{\lsttext{\%0 = call @}}id
%\text{\lsttext{_internal()}}\\
%\text{ptrtoint
%&\kw{\%1 = call @mask()}\\
%&\text{\lsttext{ret \%0\}}}&\\
%%\compile{\bar{S};\bar{M};e} \makes \compile{\bar{M}}^{\bar{S}};\compile{e}\\ 
%%%\compile{\bar{M}}^{\bar{S}}\makes \compile{M_{i}:S_{i} = \bar{d}};\compile{\bar{M}}^{\bar{S}}\\
%%%\compile{M_{i}:S_{i} = \bar{d}} \makes \compile{\bar{d}}^{S_{i}} \mathit{\ with\ } S_{i} \in \bar{S} \\
%%%\compile{d:\bar{d}}^{S_{i}} \makes \compile{d}^{S_{i}};\compile{\bar{d}}^{S_{i}}
%\end{aligned}
%\end{align*}