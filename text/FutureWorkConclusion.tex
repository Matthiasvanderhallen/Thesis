\chapter{Conclusion}
\label{chap:conclusion}
First, this chapter discusses related work in \myref{sec}{sec:relatedwork}.
It continues by discussing possible future work in section \myref{sec}{sec:FutureWork}.
A conclusion to the work is formulated as well in \myref{sec}{sec:Conclusion}

\section{Related Work}
\label{sec:relatedwork}
Lots of work trying to preserve the security of a source languages when compiling exists.
The idea of using full abstraction to formalize secure compilation is introduced by Abadi~\cite{Abadi}.
Different techniques to achieve this were developed, for example using \emph{Address Space Layout Randomization} or ASLR.
The idea of ASLR catched on, and ASLR saw implementations in common Operating Systems such as Windows Vista, OS X Mountain Lion and some Linux distributions. 
The idea also raised scientific study, for example by Abadi and Plotkin~\cite{AbadiASLR} or Jagadeesan, et al.\cite{Jagadeesan} and criticism~\cite{Shacham:2004:EAR:1030083.1030124,Strackx:2009:BMS:1519144.1519145}.

Other techniques work by introducing security guarantees to memory access.
For example, Agten et al.~\cite{Agten:2012:SCM:2354412.2355247} already provide a secure compilation scheme for an object based language, when access to memory is restricted based on the value of the program counter. This technique is called \emph{Program Counter Based Access Control}, or \emph{PCBAC}~\cite{PCBAC}.
Later work by Patrignani et al.~\cite{Patrignani} introduced additional object oriented features to the fully abstract compilation scheme.

The restricted access of memory can be implemented in hardware\cite{Sancus,SGX} or using software\cite{Fides,Salus}.
This choice effects the size of the trusted computing base or \emph{TCB}.
Even with fully abstract compilation, security issues in the TCB could lead to low-level attaques.
A recent innovation in restricting access on a hardway level is Intel\textregistered Software Guard Extensions, or \emph{SGX}~\cite{SGX}.

\section{Future Work}
\label{sec:FutureWork}
The \MiniML\ language as described in \myref{chap}{chap:FormalizationOfAdvancedConcepts} still does not provide the full feature set of ML. This section proposes some valuable extensions that could be made to the language.

\begin{itemize}
\item
Currently, the \MiniML\ language allows only a very restricted set of types to be communicated between the secure and insecure code. 
Arrays and pairs can be used within a structure or to implement an opaque type, but they cannot be the argument or return value of a publicly available function or the type of a public field.
This is not a very limiting restriction: a structure can be created to implementing an abstract data type (ADT) that behaves like a list.

However, it could still be a valuable expansion to the language to once again allow lists and pairs as a basic and first class type in the Module language.
As mentioned in \myref{sec}{sec:insecurevaluessecureclosure}, the call-by-value~\cite{Milner:1997:DSM:549659} semantics and declarative style of the ML source language do make this addition more difficult.

For example, when passing a list from the insecure context to a function in the secure code, in source-level semantics this list is passed as a value, and its content is immutable.

As the insecure memory is readable by secure code, the target language translation of the function can read the list directly from the memory, without passing execution to the insecure code.
As the attack described in \myref{sec}{sec:insecurevaluessecureclosure} shows, this capability can introduce security risks if the inherently mutable  memory is changed during a callback to insecure code.
\item
The full-fledged ML language is aware of mutable memory locations, using the concept of a reference type \lsttext{ref $\ \tau$}.
Future work could add this type to \MiniML.

\item
\MiniML\ functors are monadic, they only take a single argument structure.
There are several ways of introducing polyadic functors into \MiniML.
One would work with the current version of \MiniML:
A functor taking multiple arguments could be decomposed in several functors that take a single argument, and output a structure for the next functor to be applied to. 
A drawback to this is that the current \MiniML\ implementation would make each of the intermediate structures available.

Possibly nicer ways of implementing this functionality are:
\begin{itemize}
\item Implementing polyadic functors as real functors whose stubs take more than one frame argument.
Additional difficulties would represent themselves in the way structures are represented by frames.
\item The addition of substructures to the module language.
\end{itemize}
\item
As \LLVMIR\ is not architecture aware, not all necessary security precautions can be described in \LLVMIR.
Specifically, methods of manipulating the stack pointer or the return address are either experimental or nonexistent.

These security precautions are mentioned here, and should be added when the \LLVMIR\ is eventually compiled to machine code for a \emph{Protected Module Platform}~\cite{ref}{PCBAC} by the LLVM backend.
\end{itemize}


\section{Conclusion}
\label{sec:Conclusion}
The goal of this thesis was to describe a secure compilation scheme for a language that implements ML-style modules.
\begin{itemize}
\item
\myref{chap}{chap:ACompilationExample} and \myref{chap}{chap:formalspecification} of this thesis describe and formalize a basic version of \MiniML\ and its secure compilation scheme.
Many of the concepts introduced in literature regarding the secure compilation other, object oriented languages can be reused with only small modifications.

\item
\myref{chap}{chap:AdvancedConcepts} expanded the \MiniML\ language, with \myref{chap}{chap:FormalizationOfAdvancedConcepts} providing a formalization of the additions.
While ML is  still a larger and more capable language than the \MiniML\ language of \myref{chap}{chap:FormalizationOfAdvancedConcepts}, the final version of the language does include functors, one of the most important features of MLs powerful module language, as well as closures.
\end{itemize}

\myref{sec}{sec:formalizedcompiler2} formalized a compilation scheme for these additions, bringing secure compilation to an ML-style module language, thereby achieving the original goal of this thesis. 
%Additionally, an informal proof was given in \myref{chap}{chap:InformalProof} that suggests that this compilation is indeed a secure compilation.