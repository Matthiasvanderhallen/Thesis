\chapter{Advanced Concepts: Formalization}

First, \myref{sec}{sec:formalspec2} of this chapter will extend the formalization made in \myref{chap}{chap:formalspecification} with the additions made in \myref{chap}{chap:AdvancedConcepts}.
Later, in \myref{sec}{sec:formalizedcompiler2} extend upon the secure compiler as it was formalized in \myref{sec}{sec:formalizedcompiler}.

\section{Formal Specification of \MiniML}
\label{sec:formalspec2}
The \MiniML\ language as specified in \myref{chap}{chap:formalspecification} consisted of a very limited subset of the ML language.
In \myref{chap}{chap:AdvancedConcepts}, this issue was addressed by adding two more concepts to the subset:
\begin{description}
\item[Higher-order functions]
The concept of \emph{higher-order functions} allows that functions receive other functions as their input, or return functions as their output.
By allowing them to be assigned as a value to a variable, functions essentially become \emph{first-class values}, going by the name \emph{closure}.

To implement closures, the ability to create anonymous functions using the $\lambda$-notation is added.
This addition makes it possible to define a function as: \cmath{\lambda(\overline{x}:\overline{\sigma}).e}.
This expression is considered as the construction of a closure.

These expressions are also the \emph{only} way of constructing a closure, as explained in \myref{sec}{sec:OnlyLambdaClosures} on page \pageref{sec:OnlyLambdaClosures}. 
Essentially, when a named function is used as a closure, this is considered to be syntactic sugar.
Its desugared form is an expression in which a closure is explicitly constructed using the $\lambda$-notation to wrap around the named function.

\item[Functors]
The idea of functors is that they act as functions from structures to structures.
They provide a way to parametrizing structures.
A parametrized structure is a structure \cmath{Str_{1}} that, instead of depending on another structure \cmath{Str_{2}} by name, receives this structure as an argument.

To ensure that the structure given as an argument defines the necessary bindings, the argument structure is restricted by a signature \cmath{Sig}.
The functor definition defines all bindings of the parametrized structure.

The application of a functor \cmath{F} to a \cmath{Str_{1}}, written as \cmath{F(Str_{1})} then results in a new structure \cmath{Str_{2}} that can be bound to an identifier.
This resulting structure, or \emph{output} structure, can be used like any regular structure. Any time the functor bindings uses \cmath{ArgStr.x}, \cmath{Str_{2}} uses \cmath{Str_{1}.x}.

\end{description}

\subsection{Syntax}
\subsection{Type system}
\subsection{Operational Semantics}

\section{Formalized Compiler}
\label{sec:formalizedcompiler2}