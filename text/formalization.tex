\renewcommand{\makes}{& \ensuremath{\rightarrow} &}
\renewcommand{\compile}[1]{[[#1]]}
\newcommand{\intertextt}[1]{
& & \\
\multicolumn{3}{p{\textwidth}}{#1}\\
& & \\
}
\newcommand{\annot}[1]{[#1]}
\newcommand{\nl}{\\ & &}

\begin{longtable}{l c l}
\compile{$\overline{me}$} \makes \compile{sort($\overline{me}$)}\\

\intertextt{
Next, all module expressions can be translated individually.
The signature \cmath{SigId} used in the ascription of \cmath{StrId} is saved:
}

\compile{\cmath{me, \overline{me}}} \makes \compile{sort($\overline{me}$)} \\
\compile{\cmath{StrId:SigId = \overline{d}}} \makes \compile{$\overline{d}$}\cmath{^{SigId}}\\

\intertextt{
All fields in a module are sorted alphabetically as well. 
This is done for the same reason as the sorting of module expressions: two \MiniML\ programs \cmath{P} differing only in the order of their fields are contextually equivalent.
To prevent leakage of this ordering in the target-level, outputting the fields in the target language happens in a fixed ordering.
}

\compile{$\overline{d}$}\cmath{^{SigId}} \makes \compile{sort($\overline{d}$)}\cmath{^{SigId}} \\

\intertextt{
The compiler can now continue by translating the elements specified within the module expression.
Every definition is translated separately.
}
\compile{$\overline{d}$}$^{\mathit{SigId}}$ \makes \compile{$d$}$^{\mathit{SigId}}$;\compile{$\overline{d}$}$^{\mathit{SigId}}$\\

\intertextt{
The translation of a definition depends on a number of things.
\begin{itemize}
\item Whether the definition is that of a type or that of a field.
%The definition of a type is not translated to llvm.
\item Whether or not the value is local to the structure \cmath{StrId}.
This depends on the value being declared in the signature \cmath{SigId}.
\end{itemize}
}

\compile{\lsttext{val} $id = e : \tau$}$^{\mathit{SigId}}$ \makes \lsttext{define private\ $\tau$* @}$id$\lsttext{_internal()\{} \compile{$e$}$^{\mathit{SigId}}$ \lsttext{\}} \nl
\lsttext{define i32 @}$id$ \lsttext{()\{} \nl
\longspace [Switch stack, move parameters, add entry point \nl \longspace in spm for @\cmath{id}]\nl
\longspace \lsttext{\%0 = call @}$id$\lsttext{_internal()} \nl
\longspace \lsttext{\%1 = ptrtoint $\ \tau$* \%0 i32} \nl
\longspace \lsttext{\%2 = call @mask(\%1)} \nl
\longspace [Switch stack, clear registers] \nl
\longspace \lsttext{ret \%2} \nl
\lsttext{\}} \\
& & \\
\compile{\lsttext{fun\ $\cmath{id\ \overline{x} = e : \tau}$}}$^{\mathit{SigId}}$ \makes \lsttext{define private\ $\tau$* @}$id$\lsttext{_internal($\mathit{\overline{\tau_{x}*}\ \overline{x}}$)\{}\nl
\longspace \compile{$e$}$^{\mathit{SigId}}$ \nl
\lsttext{\}} \nl
\lsttext{define i32 @}$id$ \lsttext{($\mathit{\overline{i32\ y}}$)\{} \nl
\longspace [Switch stack, move parameters, add entry point \nl \longspace in spm for @\cmath{id}]\nl
\longspace \lsttext{$\overline{\%z}$ = call @unmask($\overline{\%y}$)} \nl
\longspace \lsttext{$\overline{\%x}$ = inttoptr i32*\ $\overline{\%y}\ \overline{\tau_{x}*}$} \nl
\longspace \lsttext{\%0 = call @}$id$\lsttext{_internal($\overline{\%y}$)} \nl
\longspace \lsttext{\%1 = ptrtoint $\ \tau$* \%0 i32} \nl
\longspace \lsttext{\%2 = call @mask(\%1)} \nl
\longspace [Switch stack, clear registers] \nl
\longspace \lsttext{ret \%2} \nl
\lsttext{\}} \\
\end{longtable}
